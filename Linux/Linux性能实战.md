# 概览

性能分析步骤：

1. 选择指标评估应用程序和系统性能
2. 为应用程序和系统设置性能目标
3. 进行性能基准测试
4. 性能分析定位瓶颈
5. 优化系统和应用程序
6. 性能监控和告警

总结起来就是：指标-测试-优化



下图是Linux常用性能工具图谱

![img](Linux性能实战_images/linux_perf_tools_full-20200918112736933.png)

# CPU

## 平均负载

什么是平均负载？

平均负载是指单位时间内，系统处于可运行状态可不可中断状态的平均进程数，也就是平均活跃进程数，它和CPU使用率并没有直接关系。

- 可运行状态的进程，是指正在使用CPU或者正在等待CPU的进程，常用ps命令看到处于R（Running或Runnable）的进程
- 不可中断状态的进程则是处于内核态关键流程中的进程，并且这些流程是不可打断的，如最常见的是等待硬件设备的I/O响应，ps命令中看到的D状态的进程



在评判系统平均负载时，需要了解系统的CPU个数，可以使用`top`或者从`proc/cpuinfo`中读取

```bash
grep 'model name' /proc/cpuinfo|wc -l
```

当平均负载大于CPU个数时，系统已经出现了过载，一般超过70%应该需要排查负载高的原因。



CPU使用率表示的是单位时间内CPU繁忙情况的统计，而平均负载是指单位时间内处于可运行状态和不可中断状态的进程数，不仅包含了正在使用CPU的进程，还包括了CPU和等待I/O的进程

- CPU密集型进程，使用大量CPU会导致平均负载升高，此时CPU使用率也是很高的
- I/O密集型进程，等待I/O会导致平均负载升高，但CPU使用率不一定很高
- 大量等待CPU的进程调度也会导致平均负载升高，CPU使用率也会比较高



可以使用下工具进行CPU的平均负载测试（apt-get install -y stress stress-ng sysstat）

- `uptime`：查看平均负载的工具
- `stress`： Linux 系统压力测试工具
- `stress-ng`：stress的高级版本
- `mpstat`：是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
- `pidstat`：pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。

打开三个终端

**终端一**

```
//在终端中每次输入完以下指令后，在看终端二、三
stress -c 1 --timeout 600
stress -i 1 --hdd 1 --timeout 600
stress -c 8 --timeout 600
```

**终端二**

```
watch -d uptime
```

**终端三**

```
mpstat -P ALL 5
pidstat -u 5
```

## 上下文切换

CPU上下文切换：将先前一个人的CPU上下文（也就是CPU寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后跳转到程序计数器所指的新位置，运行新任务。



CPU上下文切换可分为三个场景

1. 进程上下文切换
2. 线程上下文切换
3. 中断上下文切换

**进程上下文切换**

- 系统调用：特权模式切换
- 进程上下文切换：进程上下文切换比系统调用多了异步-保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存、堆栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。

当存在大量进程上下文切换时，将会导致CPU将大量时间耗费在寄存器、内核以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。

**线程上下文切换**

线程是调度的基本单位，进程时资源拥有的基本单位。内核中的任务调度实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局标量等资源。

- 多个线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的
- 线程由自己的私有数据，比如栈和寄存器等，这些在上下文切换时需要保存

根据上面对比可以发现，同一进程内部，多个线程的上下文切换的开销肯定是要小于多个进程的上下文开销，因为线程共享同一进程的虚拟内存和全局变量，在线程切换时只需要保存私有数据。

**中断上下文切换**

中断会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。

和进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正在用户态的进程，也不需要保存和恢复这个进程的虚拟内存。全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所比需的状态，包括CPU寄存器、内核堆栈、硬件中断参数等

对同一个CPU来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生。



上下文切换常用vmstat工具查看，该工具主要分析系统CPU上下文切换和中断以及内存使用情况

![image-20200921173332814](Linux性能实战_images/image-20200921173332814.png)

- cs(context switch):每秒上下文切换的次数
- in(interrupt)：每秒钟中断次数
- r(Runing or Runnable)：就绪队列的长度，正在运行和等待CPU的进程数
- b(blocked):处于不可中断睡眠状态的进程数

![image-20200921173439220](Linux性能实战_images/image-20200921173439220.png)

- cswch：表示每秒自愿上下文切换的次数
- nvcswch：表示每秒非自愿上下文切换的次数

> 自愿上下文切换：指进程无法获取所需资源，导致的上下文切换。如：I/O、内存等系统资源不足时，就会发生自愿上下文切换
>
> 非自愿上下文切换：指进程由于时间片已到等原因，被西永强制调度，进而发生的上下文切换。如：大量进程争抢CPU时，容易发生非自愿上下文切换

模拟大量线程上下文切换情况

```
sysbench --num-threads=10 --max-time=300 --test=threads run
```

同时再另外一个终端内输入

```
vmstat 1
```

注意观察`r`,`in`,`cs`,`us`,`sys`这几列，在`r`列数值变高时，`us`和`sys`加起来基本上快要有100%，`sys`表示系统占用，该值过高表示CPU主要是被内核占用了。

![image-20200921174521280](Linux性能实战_images/image-20200921174521280.png)

使用如下指令只能看出进程占用CPU很高，但是进程的上下文切换数值不高

```
pidstat -w -u 1
```

使用如下指令看线程的上下文切换

```
pidstat -wt 1
```

上述也说了，中断数量过多，可以通过如下指令查看何种中断导致

```
watch -d cat /proc/interrupts
```

可以发现变化速度最快的是重调度中断(RES),这个终端类型表示，唤醒空闲状态的CPU来调度新的任务运行。这是多处理器系统(SMP)中，调度器用来分散任务到不同CPU的机制，通常也被称为处理器间中断。



上下文切换次数取决于系统本身CPU的性能。系统的上下文切换次数比较稳定，从数百到一万以内，都应该算是正常的。但是当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，可能会出现性能问题

- 自愿上下文切换变多，说明进程都在等待资源
- 非资源上下文切换变多，说明进程都在被强制调度，也就是在争抢CPU，此时CPU成为瓶颈
- 中断次数变多，需要通过`/proc/interrupts`文件来分析具体中断类型